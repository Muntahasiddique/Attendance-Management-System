<!DOCTYPE html>
<html lang="en">
  <%- include("./includes/head.ejs", { title: "Live Terminal" }) %>
  <script defer src="/scripts/face-api.min.js"></script>
</head>
<body class="bg-background min-h-screen">
  <div id="sidebarOverlay" class="fixed inset-0 bg-black/50 z-40" onclick="toggleSidebar()"></div>
  <%- include("./includes/sidebar.ejs", {active: "terminal"}) %>

  <main id="mainContent" class="ml-64 p-8 transition-all duration-300">
    <div class="mb-8">
      <h1 class="text-2xl font-bold text-foreground">Attendance Terminal</h1>
      <p class="text-muted mt-1">Real-time facial recognition attendance system</p>
    </div>

    <!-- Configuration Panel -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
      <div class="bg-card border border-border rounded-xl p-6">
        <h3 class="font-semibold text-foreground mb-4">Teacher Information</h3>
        <div class="space-y-2">
          <div><p class="text-sm text-muted">Name</p><p class="font-medium text-foreground"><%= user ? user.fullName : 'Not Logged In' %></p></div>
          <div><p class="text-sm text-muted">Email</p><p class="font-medium text-foreground"><%= user ? user.email : '-' %></p></div>
        </div>
      </div>

      <div class="bg-card border border-border rounded-xl p-6">
        <h3 class="font-semibold text-foreground mb-4">Select Class</h3>
        <select id="classSelect" class="w-full px-4 py-3 bg-background border border-border rounded-lg text-foreground focus:outline-none focus:ring-2 focus:ring-primary">
          <option value="">Choose a class...</option>
        </select>
        <p id="classStudentCount" class="text-sm text-muted mt-2"></p>
      </div>

      <div class="bg-card border border-border rounded-xl p-6">
        <h3 class="font-semibold text-foreground mb-4">Select Course</h3>
        <select id="courseSelect" disabled class="w-full px-4 py-3 bg-background border border-border rounded-lg text-foreground focus:outline-none focus:ring-2 focus:ring-primary disabled:opacity-50">
          <option value="">Choose a course...</option>
        </select>
        <p id="courseCode" class="text-sm text-muted mt-2"></p>
      </div>
    </div>

    <!-- Camera and Activity -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <div class="lg:col-span-2">
        <div class="bg-card border border-border rounded-xl overflow-hidden">
          <div class="p-4 border-b border-border flex items-center justify-between">
            <div class="flex items-center gap-2">
              <div id="statusDot" class="w-2 h-2 bg-muted rounded-full"></div>
              <span id="statusText" class="text-sm text-muted">Standby</span>
            </div>
            <div class="flex gap-2">
              <button id="startBtn" onclick="startRecognition()" disabled class="px-4 py-2 bg-primary text-background font-medium rounded-lg hover:bg-primary/90 transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                Start Recognition
              </button>
              <button id="stopBtn" onclick="stopRecognition()" disabled class="px-4 py-2 bg-danger text-background font-medium rounded-lg hover:bg-danger/90 transition-all disabled:opacity-50 disabled:cursor-not-allowed hidden">
                Stop Recognition
              </button>
            </div>
          </div>
          
          <div class="relative bg-black aspect-video">
            <video id="videoElement" class="w-full h-full object-cover" autoplay muted playsinline></video>
            <img id="ipCameraElement" class="w-full h-full object-cover hidden" />
            <canvas id="overlay" class="absolute top-0 left-0 w-full h-full"></canvas>
            
            <div id="cameraOff" class="absolute inset-0 flex flex-col items-center justify-center bg-background">
              <svg class="w-16 h-16 text-muted mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
              </svg>
              <p class="text-muted">Camera not active</p>
            </div>
          </div>

          <div class="p-4 grid grid-cols-3 gap-4 bg-background">
            <div class="text-center">
              <p class="text-2xl font-bold text-primary" id="markedCount">0</p>
              <p class="text-xs text-muted">Marked</p>
            </div>
            <div class="text-center">
              <p class="text-2xl font-bold text-foreground" id="totalStudents">0</p>
              <p class="text-xs text-muted">Total</p>
            </div>
            <div class="text-center">
              <p class="text-2xl font-bold text-warning" id="pendingCount">0</p>
              <p class="text-xs text-muted">Pending</p>
            </div>
          </div>
        </div>
      </div>

      <div class="bg-card border border-border rounded-xl flex flex-col max-h-[600px]">
        <div class="p-4 border-b border-border">
          <h3 class="font-semibold text-foreground">Today's Attendance</h3>
          <p class="text-xs text-muted mt-1">Live feed</p>
        </div>
        <div id="activityFeed" class="flex-1 overflow-y-auto p-4 space-y-3">
          <div class="text-center text-muted py-8">
            <p class="text-sm">No attendance marked yet</p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    let stream = null;
    let isRecognitionActive = false;
    let studentDescriptors = [];
    let markedStudents = new Set();
    let selectedClassId = null;
    let selectedCourseId = null;
    let faceMatcher = null;
    let isUsingIPCamera = false;
    let userSettings = null; // Store user settings for face recognition

    async function loadTeacherData() {
      try {
        const response = await fetch('/terminal/api/teacher-data');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        const classSelect = document.getElementById('classSelect');
        classSelect.innerHTML = '<option value="">Choose a class...</option>';
        
        if (!data.classes || data.classes.length === 0) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'No classes assigned';
          option.disabled = true;
          classSelect.appendChild(option);
          return;
        }
        
        data.classes.forEach(cls => {
          const option = document.createElement('option');
          option.value = cls._id;
          option.textContent = cls.displayName;
          option.dataset.courses = JSON.stringify(cls.courses);
          classSelect.appendChild(option);
        });
      } catch (error) {
        console.error('Error loading teacher data:', error);
        alert('Failed to load teacher data: ' + error.message);
      }
    }

    document.getElementById('classSelect').addEventListener('change', async (e) => {
      const classId = e.target.value;
      const courseSelect = document.getElementById('courseSelect');
      const startBtn = document.getElementById('startBtn');
      
      if (!classId) {
        courseSelect.disabled = true;
        courseSelect.innerHTML = '<option value="">Choose a course...</option>';
        startBtn.disabled = true;
        document.getElementById('classStudentCount').textContent = '';
        return;
      }
      
      selectedClassId = classId;
      
      const courses = JSON.parse(e.target.selectedOptions[0].dataset.courses);
      courseSelect.innerHTML = '<option value="">Choose a course...</option>';
      courses.forEach(course => {
        const option = document.createElement('option');
        option.value = course._id;
        option.textContent = course.name;
        option.dataset.code = course.code;
        courseSelect.appendChild(option);
      });
      courseSelect.disabled = false;
      
      try {
        const response = await fetch(`/terminal/api/class-students/${classId}`);
        const data = await response.json();
        studentDescriptors = data.students;
        
        document.getElementById('classStudentCount').textContent = `${studentDescriptors.length} students enrolled`;
        document.getElementById('totalStudents').textContent = studentDescriptors.length;
        
        if (studentDescriptors.length > 0 && typeof faceapi !== 'undefined') {
          const labeledDescriptors = studentDescriptors.map(student => {
            const descriptors = [new Float32Array(student.faceDescriptor)];
            return new faceapi.LabeledFaceDescriptors(student._id.toString(), descriptors);
          });
          // Use matchingThreshold from settings if available, otherwise default to 0.6
          const threshold = userSettings?.matchingThreshold || 0.6;
          faceMatcher = new faceapi.FaceMatcher(labeledDescriptors, threshold);
        }
      } catch (error) {
        console.error('Error loading students:', error);
      }
    });

    document.getElementById('courseSelect').addEventListener('change', (e) => {
      const courseId = e.target.value;
      const startBtn = document.getElementById('startBtn');
      
      if (!courseId) {
        startBtn.disabled = true;
        document.getElementById('courseCode').textContent = '';
        return;
      }
      
      selectedCourseId = courseId;
      const courseCode = e.target.selectedOptions[0].dataset.code;
      document.getElementById('courseCode').textContent = `Code: ${courseCode}`;
      startBtn.disabled = false;
      
      loadTodayAttendance();
    });

    async function loadTodayAttendance() {
      try {
        const response = await fetch(`/terminal/api/today-attendance/${selectedCourseId}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        const activityFeed = document.getElementById('activityFeed');
        activityFeed.innerHTML = '';
        
        if (!data.attendance || data.attendance.length === 0) {
          activityFeed.innerHTML = '<div class="text-center text-muted py-8"><p class="text-sm">No attendance marked yet</p></div>';
          return;
        }
        
        data.attendance.forEach(record => {
          const studentId = record.studentRef?._id || record.studentRef;
          if (studentId) {
            markedStudents.add(studentId.toString());
          }
          addActivityItem(record);
        });
        
        updateStats();
      } catch (error) {
        console.error('Error loading attendance:', error);
        const activityFeed = document.getElementById('activityFeed');
        activityFeed.innerHTML = '<div class="text-center text-muted py-8"><p class="text-sm">Failed to load attendance</p></div>';
      }
    }

    async function startRecognition() {
      if (!selectedClassId || !selectedCourseId) {
        alert('Please select a class and course first');
        return;
      }
      
      const startBtn = document.getElementById('startBtn');
      
      if (!isRecognitionActive) {
        try {
          // Fetch user settings for face recognition
          const settingsResponse = await fetch('/api/settings');
          if (settingsResponse.ok) {
            userSettings = await settingsResponse.json();
          }
          
          // Fetch camera settings from server
          const settingsRes = await fetch('/api/camera/stream-url');
          const cameraSettings = await settingsRes.json();
          
          const video = document.getElementById('videoElement');
          const ipImg = document.getElementById('ipCameraElement');
          const cameraOffDiv = document.getElementById('cameraOff');
          
          console.log('Camera settings:', cameraSettings);
          
          if (cameraSettings.cameraType === 'ip' && cameraSettings.streamUrl) {
            // Use IP camera via MJPEG HTTP stream (simple like Python cv2)
            isUsingIPCamera = true;
            
            // Hide video element and show img
            video.style.display = 'none';
            ipImg.style.display = 'block';
            ipImg.src = '/api/camera/stream';
            
            // Add error handler for IP camera
            ipImg.onerror = () => {
              console.error('Failed to load IP camera stream');
              stopRecognition();
            };
            
            ipImg.onload = () => {
              console.log('IP camera loaded:', ipImg.naturalWidth, 'x', ipImg.naturalHeight);
            };
            
            cameraOffDiv.style.display = 'none';
            
            console.log('IP camera connected via MJPEG stream');
          } else {
            // Use built-in webcam
            isUsingIPCamera = false;
            
            try {
              stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                  width: { ideal: 1280 }, 
                  height: { ideal: 720 },
                  facingMode: 'user'
                } 
              });
              
              console.log('Webcam stream obtained');
              
              video.srcObject = stream;
              video.style.display = 'block';
              ipImg.style.display = 'none';
              
              // Wait for video metadata to load
              await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                  reject(new Error('Video loading timeout'));
                }, 5000);
                
                video.onloadedmetadata = () => {
                  clearTimeout(timeout);
                  console.log('Video metadata loaded');
                  video.play()
                    .then(() => {
                      console.log('Video playing');
                      resolve();
                    })
                    .catch(err => {
                      console.error('Error playing video:', err);
                      reject(err);
                    });
                };
              });
              
              cameraOffDiv.style.display = 'none';
              console.log('Webcam started:', video.videoWidth, 'x', video.videoHeight);
            } catch (err) {
              console.error('Webcam error:', err);
              throw new Error('Failed to access webcam: ' + err.message);
            }
          }
          
          await Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri('/scripts'),
            faceapi.nets.faceLandmark68Net.loadFromUri('/scripts'),
            faceapi.nets.faceRecognitionNet.loadFromUri('/scripts')
          ]);
          
          isRecognitionActive = true;
          startBtn.disabled = true;
          startBtn.classList.add('hidden');
          
          const stopBtn = document.getElementById('stopBtn');
          stopBtn.disabled = false;
          stopBtn.classList.remove('hidden');
          
          updateStatus('active', 'Recognizing...');
          recognizeFaces();
        } catch (error) {
          console.error('Error:', error);
          alert('Unable to start camera: ' + error.message);
        }
      }
    }

    function stopRecognition() {
      isRecognitionActive = false;
      
      // Stop webcam stream
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      
      // Stop IP camera
      if (isUsingIPCamera) {
        const ipImg = document.getElementById('ipCameraElement');
        ipImg.src = '';
        ipImg.style.display = 'none';
        isUsingIPCamera = false;
      }
      
      const video = document.getElementById('videoElement');
      video.srcObject = null;
      video.style.display = 'block';
      
      document.getElementById('cameraOff').style.display = 'flex';
      const canvas = document.getElementById('overlay');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const startBtn = document.getElementById('startBtn');
      startBtn.disabled = false;
      startBtn.classList.remove('hidden');
      
      const stopBtn = document.getElementById('stopBtn');
      stopBtn.disabled = true;
      stopBtn.classList.add('hidden');
      
      updateStatus('standby', 'Standby');
    }

    async function recognizeFaces() {
      if (!isRecognitionActive) return;
      
      const video = document.getElementById('videoElement');
      const ipImg = document.getElementById('ipCameraElement');
      
      // Wait for source element to be ready
      if (isUsingIPCamera && !ipImg.complete) {
        setTimeout(recognizeFaces, 100);
        return;
      } else if (!isUsingIPCamera && !video.videoWidth) {
        setTimeout(recognizeFaces, 100);
        return;
      }
      
      const overlayCanvas = document.getElementById('overlay');
      
      const displaySize = isUsingIPCamera
        ? { width: ipImg.naturalWidth || 1280, height: ipImg.naturalHeight || 720 }
        : { width: video.videoWidth || 1280, height: video.videoHeight || 720 };
      
      overlayCanvas.width = displaySize.width;
      overlayCanvas.height = displaySize.height;
      faceapi.matchDimensions(overlayCanvas, displaySize);
      
      const detectFaces = async () => {
        if (!isRecognitionActive) return;
        
        const sourceElement = isUsingIPCamera ? ipImg : video;
        
        // Check if source is ready
        if (isUsingIPCamera && !ipImg.complete) {
          setTimeout(detectFaces, 100);
          return;
        } else if (!isUsingIPCamera && !video.videoWidth) {
          setTimeout(detectFaces, 100);
          return;
        }
        
        const detections = await faceapi.detectAllFaces(
          sourceElement, 
          new faceapi.TinyFaceDetectorOptions({ 
            inputSize: userSettings?.inputSize || 416,
            scoreThreshold: 0.5 
          })
        ).withFaceLandmarks().withFaceDescriptors();
        const resizedDetections = faceapi.resizeResults(detections, displaySize);
        
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        
        resizedDetections.forEach(detection => {
          const bestMatch = faceMatcher.findBestMatch(detection.descriptor);
          const box = detection.detection.box;
          
          const isMarked = markedStudents.has(bestMatch.label.toString());
          // Use matchingThreshold from settings
          const threshold = userSettings?.matchingThreshold || 0.6;
          const isMatch = bestMatch.label !== 'unknown' && bestMatch.distance < threshold;
          
          ctx.strokeStyle = isMarked ? '#10b981' : (isMatch ? '#f59e0b' : '#ef4444');
          ctx.lineWidth = 3;
          ctx.strokeRect(box.x, box.y, box.width, box.height);
          
          const label = isMatch ? (isMarked ? '✓ MARKED' : `${(1 - bestMatch.distance).toFixed(2)}`) : 'UNKNOWN';
          
          ctx.fillStyle = isMarked ? '#10b981' : (isMatch ? '#f59e0b' : '#ef4444');
          ctx.font = '16px Inter';
          const textWidth = ctx.measureText(label).width;
          ctx.fillRect(box.x, box.y - 25, textWidth + 10, 25);
          ctx.fillStyle = '#ffffff';
          ctx.fillText(label, box.x + 5, box.y - 7);
          
          if (isMatch && !isMarked) {
            markAttendance(bestMatch.label, 1 - bestMatch.distance);
          }
        });
        
        setTimeout(detectFaces, 200);
      };
      
      detectFaces();
    }

    async function markAttendance(studentId, confidenceScore) {
      if (!studentId || !selectedCourseId || !selectedClassId) {
        console.error('Missing required data for attendance marking');
        return;
      }
      
      if (markedStudents.has(studentId.toString())) return;
      
      try {
        const response = await fetch('/terminal/api/mark-attendance', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            studentId: studentId.toString(), 
            courseId: selectedCourseId, 
            classId: selectedClassId, 
            confidenceScore 
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          console.error('Attendance marking failed:', errorData.error);
          return;
        }
        
        const data = await response.json();
        
        if (data.success) {
          markedStudents.add(studentId.toString());
          addActivityItem(data.attendance);
          updateStats();
        } else if (data.alreadyMarked) {
          markedStudents.add(studentId.toString());
        }
      } catch (error) {
        console.error('Error marking attendance:', error);
      }
    }

    function addActivityItem(record) {
      const activityFeed = document.getElementById('activityFeed');
      
      if (activityFeed.querySelector('.text-center')) {
        activityFeed.innerHTML = '';
      }
      
      const initials = record.student.fullName.split(' ').map(n => n[0]).join('');
      const statusColor = record.status === 'present' ? 'primary' : 'warning';
      const statusLabel = record.status === 'present' ? 'PRESENT' : 'LATE';
      const time = new Date(record.timestamp).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
      
      const item = document.createElement('div');
      item.className = 'flex items-center gap-3 p-3 bg-background rounded-lg border border-' + statusColor + '/20';
      item.innerHTML = `
        <div class="w-10 h-10 rounded-full bg-${statusColor}/20 flex items-center justify-center text-${statusColor} font-semibold text-sm">${initials}</div>
        <div class="flex-1 min-w-0">
          <p class="font-medium text-foreground text-sm truncate">${record.student.fullName}</p>
          <p class="text-xs text-muted">${record.student.rollNo}</p>
        </div>
        <div class="text-right">
          <span class="text-xs font-medium text-${statusColor}">${statusLabel}</span>
          <p class="text-xs text-muted">${time}</p>
        </div>
      `;
      
      activityFeed.insertBefore(item, activityFeed.firstChild);
    }

    function updateStats() {
      document.getElementById('markedCount').textContent = markedStudents.size;
      document.getElementById('pendingCount').textContent = studentDescriptors.length - markedStudents.size;
    }

    function updateStatus(status, text) {
      const dot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      
      dot.className = 'w-2 h-2 rounded-full ' + (status === 'active' ? 'bg-primary animate-pulse' : 'bg-muted');
      statusText.textContent = text;
    }

    loadTeacherData();
  </script>
</body>
</html>
